### 得分最高的最小轮调

难度：困难



给你一个数组 `nums`，我们可以将它按一个非负整数 `k` 进行轮调，这样可以使数组变为 `[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]` 的形式。此后，任何值小于或等于其索引的项都可以记作一分。

- 例如，数组为 `nums = [2,4,1,3,0]`，我们按 `k = 2` 进行轮调后，它将变成 `[1,3,0,2,4]`。这将记为 `3` 分，因为 `1 > 0` [不计分]、`3 > 1` [不计分]、`0 <= 2` [计 1 分]、`2 <= 3` [计 1 分]，`4 <= 4` [计 1 分]。

在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 `k` 。如果有多个答案，返回满足条件的最小的下标 `k` 。

 

**示例 1：**

```
输入：nums = [2,3,1,4,0]
输出：3
解释：
下面列出了每个 k 的得分：
k = 0,  nums = [2,3,1,4,0],    score 2
k = 1,  nums = [3,1,4,0,2],    score 3
k = 2,  nums = [1,4,0,2,3],    score 3
k = 3,  nums = [4,0,2,3,1],    score 4
k = 4,  nums = [0,2,3,1,4],    score 3
所以我们应当选择 k = 3，得分最高。
```

**示例 2：**

```
输入：nums = [1,3,0,2,4]
输出：0
解释：
nums 无论怎么变化总是有 3 分。
所以我们将选择最小的 k，即 0。
```

 

**提示：**

- `1 <= nums.length <= 10^5`
- `0 <= nums[i] < nums.length`





### 我的答案

```java
class Solution {
    public int bestRotation(int[] nums) {
        // e.g. [2,3,1,4,0] 
        // 前缀和 sum[10]（求k = -5 -4 -3 -2 -1 0 1 2 3 4 的得分，求两轮，前一轮表示负数）
        // 0,0,0,0,0,0,0,0,0,0
        // 0,1,1,1,0,0,0,0,0,0
        // 0,1,2,2,0,0,0,0,0,0
        // 0,1,2,3,1,1,1,0,0,0
        // 0,1,2,3,2,1,1,0,0,0
        // 0,1,2,3,2,2,2,1,1,1
        // 最终结果  2,3,3,4,3

        // 差分 dif[10]
        // 0 0 0 0 0 0 0 0 0 0
        // 0 1 0 0-1 0 0 0 0 0
        // 0 1 1 0-2 0 0 0 0 0
        // 0 1 1 1-2 0 0-1 0 0
        // 0 1 1 1-1-1 0-1 0 0
        // 0 1 1 1-1 0 0-1 0 0 (-1)

        // sum[0] = dif[0] + (dif[0]+dif[1]+...+dif[5]) = 2
        // sum[1] = (dif[0]+dif[1]) + (dif[0]+dif[1]+...+dif[6]) = 3
        // ...

        int n = nums.length;
        int[] dif = new int[2 * n];
        int[] sum = new int[n];
        for (int i = 0; i < n; i++) {
            int left = i + 1;
            int right = i - nums[i] + n + 1;
            dif[left]++;
            if (right < 2 * n)
                dif[right]--;
        }
        int max = 0;
        int maxIndex = 0;
        int total = 0;
        for (int i = 0; i < 2 * n; i++) {
            total += dif[i];
            sum[i % n] += total;
            if (i >= n) {
                if (sum[i % n] > max) {
                    max = sum[i % n];
                    maxIndex = i % n;
                }
            }
        }
        return maxIndex;
    }
}
```

首先明确题意，对于每个数字 x 来说，将 x 排到索引为 x, x+1, ... n -1 的位置上时能够得分，排到对应位置上的所需位移为 k，因此可以使用一个数组计算 k 出现的次数。遍历完 x 能得分的所有位置后，再对下一个数字进行同样操作。在这种情况下需要 O(n^2) 的时间复杂度，显然太长。

因此可以使用前缀和+差分的方法。将上一个方法得到的数组视为前缀和，前缀和的反变换差分则可以替换对每个位置的遍历。例如，对于例子 [2,3,1,4,0]，位移 0,1,2,3,4 出现的次数最开始为 0,0,0,0,0，差分为 0,0,0,0,0，第一个数字 2 可以向左位移 1,2,3，因此每个位移次数加 1，得到前缀和 0,1,1,1,0，差分变为 0,1,0,0,-1，也就是最左变化的值加 1，最右变化的右边一位的值减 1，易证得该差分的前缀和即为所给，且相比第一种方法少了大量遍历时间。

对于越过边界的情况，可以将数组变为两倍，最后相加时循环两遍，找出最大值。



时间复杂度：O(n)

空间复杂度：O(n)





### 最优答案

可以改为一倍长数组，当越过边界时，进行判断，left > right 时，可将差分分为前后两部分，每部分的头尾都加 1 减 1。做法是：差分数组首位 +1，第一部分尾部 -1，第二部分头部 +1，尾部可以不操作，因为越界并且不会使用到。等价于仍对 left 上的值 +1，right+1 上的值 -1，并且当 left > right 时，dif[0]++。

```java
class Solution {
    public int bestRotation(int[] nums) {
        int n = nums.length;
        int[] dif = new int[n];
        for (int i = 0; i < n; i++) {
            int left = (i + 1) % n;
            int right = (i - nums[i] + n + 1) % n;
            dif[left]++;
            dif[right]--;
            if (left < right)
                dif[0]++;
        }
        int max = 0;
        int maxIndex = 0;
        int total = 0;
        for (int i = 0; i < n; i++) {
            total += dif[i];
            if (total > max) {
                max = total;
                maxIndex = i;
            }
        }
        return maxIndex;
    }
}
```





### 类似题目

